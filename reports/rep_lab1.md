## OS Lab1 实验报告
### 一、思考题（按指导书中顺序）
#### Thinking 0.1

* **选项** `objdump`使用的选项：`-DS`，其中`-D`选项表示反汇编所有节，实践发现如果不加`-D`选项，只输出了`main`部分的反汇编代码。`-S`选项表示尽可能反汇编出源码。

* **参数** 传入的参数分别是需要反汇编的目标文件、重定向的输出文件。

#### Thinking 0.2

首先观察了`readelf`目录下的Makefile，发现其中`readelf`和`hello`可执行文件的编译选项不同。后者编译选项比前者多了`-m32 -static -g`，以此入手删去`hello`的该选项，再次`make hello`生成新的可执行文件，执行`./readelf hello`发现和`readelf`一样都解析不了了。顺着这个思路，给`readelf`的编译和链接选项加上`-m32 -static -g`，发现可以解析`readelf`可执行文件本身。分别用`readelf -h`解析这两个文件，发现类别分别为ELF64和ELF32。

原因：`-m32`选项指定在64位系统下编译32位程序。我们自己编写的`readelf`只能解析32位程序，没有使用`-m32`选项的`readelf`就无法解析。

#### Thinking 0.3

操作系统启动时，首先启动bootloader程序，stage1阶段先初始化硬件设备。MIPS体系结构上电时，启动入口的地址为kseg1中一个虚拟地址。将虚拟地址的高三位清零得到对应的物理地址，从物理地址开始第一条指令，完成初始化基本的硬件设备的工作，并为stage2做准备。之后进入stage2阶段的入口函数，BIOS从MBR中读取开机信息，最后BIOS跳到指定的地址运行，这样便保证内核入口被正确跳转到。

### 二、难点分析

* 练习题第一题，难点在于如何遍历节头，也就是，每一轮循环的**循环增量**是什么。在实验过程中我发现，ELF头中、节头表表项中有一些成员变量很容易搞混淆，例如ELF头中的`e_shentsize`,节头表中`sh_entsize`和`sh_size`等。

* 练习题第二题，倒也还好，不过如果没有指导书中“KERNBASE是内核镜像的其实虚拟地址”这一句话我可能就直接在链接脚本中把`.text`节直接装载到`0x80000000`也就是kseg0的起始地址处了。

* 练习题第三题，算是mips汇编的回顾，题目本身不难，难点可能是理解栈指针这个东西。

* 练习题第四题，难点是从众多文件中“顺藤摸瓜”，层次由高到低地去找到`printk`函数的底层逻辑，几层函数调用确实有些绕，不过弄清楚以后，要补全的代码只是格式字符串的控制逻辑，这样写起来就轻松多了。

### 三、实验体会

从开始看到题目觉得无从下手，到一字一句试图理解指导书的内容，最后总结lab1我觉得lab1本身代码填空的难度不大，难点其实还是在理解给出的代码框架、理解指导书以及搞清楚“到底要我做什么事”，逐步理解lab1分支下的目录文件结构、每个文件用来做什么，文件中的函数调用关系之后，思路也就逐渐清晰过来。例如，在做实验过程中，我尝试自己分析列出了文件结构以及`printk`有关函数的调用关系:

1.首先是分支目录下的几个非目录文件：

* **`Makefile`** 构建内核的总Makefile文件，前面我们已经大致分析过

* **`kernel.lds`** Linker Script链接脚本，前面我们用来控制链接和装载mos_elf相应节在内存中的位置

* **`include.mk`** Makefile里面一些用到的变量（如`$(CC)` `$(LD)`）在这里进行了定义

2.再看比较熟悉的目录：

* **`target`** mos可执行文件所在目录，也就是执行`make`命令后生成的目标文件

* **`tools`** 工具目录，例如我们第一题完成的`readelf`

* **`init`** 顾名思义，是和内核初始化有关的目录。进入目录，发现Makefile构建的目标`init.o`和`start.o`，不难猜出这就是和初始化有关的目标文件。`start.o`的依赖文件`start.S`正是第三题中补全过的汇编文件，它是整个内核的程序入口。而init.c中的`mips_init()`函数就是`start.S`中我们填写的`j`指令跳转的函数了。

3.最后逐个分析其他目录：

* **`kern`** 先看其Makefile，总目标是`include.mk`中定义的三个目标文件`console.o` `printk.o` `panic.o`，可以从其依赖文件`printk.c`和`console.c`尝试阅读。

* **`lib`** 库目录，Makefile的目标是`elfloader.o` `print.o` `string.o`，大致猜测这是一些库函数的实现。

* **`mk`** 内含两个暂时用不着细看的`.mk`文件


最后小提一句，感觉思考题部分的题目，说实话即使做完了实验，指导书也基本都看懂了，纯自己思考也想不出来...特别是第二题，进行了大量的搜索才得出答案...